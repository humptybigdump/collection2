"""
General framework for running experiments.

It consists of the following two functions:

    - L{flat_runs} takes an experiment description (or a list of
      experiment descriptions) and generates a list of runs.  Each run
      consists of an instances together with a set of options.

    - L{run_experiment} takes a list of runs (typically generated by
      L{flat_runs}), a command function that transforms a run into a
      command line command, and a result function that can parse the
      result.  It then performs all runs given.

@author: Thomas Blaesius
"""

import subprocess
import copy
import itertools
import sys


def flat_runs(experiments, global_options={}):
    """Flattens experiment descriptions into a list of simple runs.

    An experiment can be specified by listing instances together with
    default options.  The default options overwrite and complement the
    global options.  Moreover, the resulting options can be further
    overwritten and complemented on an instance-by-instance basis.
    The options can be specified using single values or lists of
    values.  When using lists, this specifies multiple runs for a
    single instance, namely one run for each possible combination of
    option values.  This method flattens the experiment specification
    to a simple list of runs, where each run consists of an instance
    together with specific single value options.

    @param experiments: An experiment specification or a list of
        experiment specifications.  An experiment specification is a
        dictionary with entries for the keys I{instances} and
        I{options}:

            - The value for I{options} has to be an options
              dictionary.  An options dictionary maps from option
              names to either single values or lists of values.

            - The value for I{instances} has to be a list of
              instances.  Each instance in this list is either just a
              string (instance name) or a list with the first item
              being a string (instance name) and the second item being
              an options dictionary overwriting or adding to the
              default options dictionary.

    @keyword global_options: The global options, which is an options
        dictionary (as the default options).  Default: empty
        dictionary

    @return: The output is a list of runs.  Each run is a dictionary
        with entries for the keys I{instance} and I{options}.  The
        I{instance} entry is just the name of the instance.  The
        I{options} entry is a map that maps option names to single
        values.
    """
    if type(experiments) is list:
        return [run for experiment in experiments
                for run in flat_runs(experiment)]
    experiment = experiments
    runs = []
    for instance in experiment["instances"]:
        # overwrite global options with default options, ix they exist
        opt = copy.deepcopy(global_options)
        for key, value in experiment["options"].items():
            opt[key] = value

        # overwrite with instance specific options, if they exist
        if type(instance) is list:
            for key, value in instance[1].items():
                opt[key] = value
            instance = instance[0]

        # generate all option combinations
        opt_keys = []
        opt_vals = []
        for key, value in opt.items():
            opt_keys.append(key)
            opt_vals.append(value if type(value) is list else [value])

        opt_comb = list(itertools.product(*opt_vals))
        for values in opt_comb:
            run = {"instance": instance, "options": {}}
            for key, value in zip(opt_keys, values):
                run["options"][key] = value
            runs.append(run)
            # print(run)
    return runs


def run_experiment(runs, command_fun, result_fun, out=sys.stdout,
                   dry_run=False):
    """Execute runs.

    Executes a given list of runs.  The function command_fun
    translates the run into an actual command line call that can be
    executed.  The function result_fun parses the result.  Its return
    value is then printed.  A dry_run can be used to just output the
    commands that would be run.  If the special option I{iterations}
    is set for a run, the given number of iterations is performed.

    @param runs: A list of runs as, e.g., returned by L{flat_runs}.

    @param command_fun: A function taking a single run as input
        returning a string; the command that corresponds to this run.

    @param result_fun: A function taking a single run as first
        argument and the result of a call to C{subprocess.run()} as
        second argument.  It has to return a string, which will be
        printed as result of the current run.

    @keyword out: Stream to which every output is printed.  Default:
        C{sys.stdout}

    @keyword dry_run: If set to C{True}, the commands are not actually
        executed.  Instead, the commands are printed.  Default:
        C{False}
    """
    for run in runs:
        cmd = command_fun(run)
        it = (run["options"]["iterations"] if "iterations" in run["options"]
              else 1)

        # only print the command if we are in a dry run
        if dry_run:
            print("[", it, "x]: ", cmd, file=out, flush=True, sep="")
            continue

        # actually run the command
        for _ in range(it):
            r = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            print(result_fun(run, r), file=out, flush=True)
